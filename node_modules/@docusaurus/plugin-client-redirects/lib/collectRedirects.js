"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const extensionRedirects_1 = require("./extensionRedirects");
const redirectValidation_1 = require("./redirectValidation");
const chalk_1 = __importDefault(require("chalk"));
function collectRedirects(pluginContext) {
    const redirects = doCollectRedirects(pluginContext);
    validateCollectedRedirects(redirects, pluginContext);
    return filterUnwantedRedirects(redirects, pluginContext);
}
exports.default = collectRedirects;
function validateCollectedRedirects(redirects, pluginContext) {
    const redirectValidationErrors = redirects
        .map((redirect) => {
        try {
            redirectValidation_1.validateRedirect(redirect);
            return undefined;
        }
        catch (e) {
            return e.message;
        }
    })
        .filter(Boolean);
    if (redirectValidationErrors.length > 0) {
        throw new Error(`Some created redirects are invalid:
- ${redirectValidationErrors.join('\n- ')}
`);
    }
    const allowedToPaths = pluginContext.relativeRoutesPaths;
    const toPaths = redirects.map((redirect) => redirect.to);
    const illegalToPaths = lodash_1.difference(toPaths, allowedToPaths);
    if (illegalToPaths.length > 0) {
        throw new Error(`You are trying to create client-side redirections to paths that do not exist:
- ${illegalToPaths.join('\n- ')}

Valid paths you can redirect to:
- ${allowedToPaths.join('\n- ')}
`);
    }
}
function filterUnwantedRedirects(redirects, pluginContext) {
    // we don't want to create twice the same redirect
    // that would lead to writing twice the same html redirection file
    Object.entries(lodash_1.groupBy(redirects, (redirect) => redirect.from)).forEach(([from, groupedFromRedirects]) => {
        if (groupedFromRedirects.length > 1) {
            console.error(chalk_1.default.red(`@docusaurus/plugin-client-redirects: multiple redirects are created with the same "from" pathname=${from}
It is not possible to redirect the same pathname to multiple destinations:
- ${groupedFromRedirects.map((r) => JSON.stringify(r)).join('\n- ')}
`));
        }
    });
    redirects = lodash_1.uniqBy(redirects, (redirect) => redirect.from);
    // We don't want to override an already existing route with a redirect file!
    const redirectsOverridingExistingPath = redirects.filter((redirect) => pluginContext.relativeRoutesPaths.includes(redirect.from));
    if (redirectsOverridingExistingPath.length > 0) {
        console.error(chalk_1.default.red(`@docusaurus/plugin-client-redirects: some redirects would override existing paths, and will be ignored:
- ${redirectsOverridingExistingPath.map((r) => JSON.stringify(r)).join('\n- ')}
`));
    }
    redirects = redirects.filter((redirect) => !pluginContext.relativeRoutesPaths.includes(redirect.from));
    return redirects;
}
// For each plugin config option, create the appropriate redirects
function doCollectRedirects(pluginContext) {
    return [
        ...extensionRedirects_1.createFromExtensionsRedirects(pluginContext.relativeRoutesPaths, pluginContext.options.fromExtensions),
        ...extensionRedirects_1.createToExtensionsRedirects(pluginContext.relativeRoutesPaths, pluginContext.options.toExtensions),
        ...createRedirectsOptionRedirects(pluginContext.options.redirects),
        ...createCreateRedirectsOptionRedirects(pluginContext.relativeRoutesPaths, pluginContext.options.createRedirects),
    ];
}
function createRedirectsOptionRedirects(redirectsOption) {
    // For conveniency, user can use a string or a string[]
    function optionToRedirects(option) {
        if (typeof option.from === 'string') {
            return [{ from: option.from, to: option.to }];
        }
        return option.from.map((from) => ({
            from,
            to: option.to,
        }));
    }
    return lodash_1.flatten(redirectsOption.map(optionToRedirects));
}
// Create redirects from the "createRedirects" fn provided by the user
function createCreateRedirectsOptionRedirects(paths, createRedirects) {
    function createPathRedirects(path) {
        const fromsMixed = createRedirects
            ? createRedirects(path) || []
            : [];
        const froms = typeof fromsMixed === 'string' ? [fromsMixed] : fromsMixed;
        return froms.map((from) => {
            return {
                from,
                to: path,
            };
        });
    }
    return lodash_1.flatten(paths.map(createPathRedirects));
}
